{
  "slug": "power-user-tips",
  "title": "Claude Code Power User Guide",
  "subtitle": "Battle-tested prompts, CLAUDE.md rules, and workflow tricks from 338 sessions",
  "date": "2026-02-27",
  "category": "Tips",
  "categoryColor": "green",
  "icon": "zap",
  "readingTime": "13 min read",
  "content": "This is the post I wish I'd read before my first session. No theory, no hype — just the specific things that make Claude Code dramatically more effective.\n\n## The Prompts That Work\n\n### Front-load vault conventions to eliminate correction loops\n\nAcross 15+ vault-related sessions, I frequently had to correct Claude about placing action items in project files vs meeting notes, routing decisions correctly, and checking for existing person notes before creating duplicates. Adding a vault conventions section to CLAUDE.md with explicit routing rules would eliminate these correction cycles entirely. My vault has clear structure — Claude just needs to be told once.\n\n:::prompt\nRead my vault's CLAUDE.md and the folder structure. Before creating any new file, always check if a matching file already exists. Action items go in project files, not meeting notes. Decisions go in project files. Meeting notes should only contain summary, attendees, and discussion points.\n:::\n\n### Break long sessions into focused tasks\n\nSessions where I drove 5+ different tasks (vault updates + deployments + research) had more partially-achieved outcomes than focused sessions. My most successful pattern is the focused flow: implement → review → PR → deploy. When I chain many unrelated tasks, Claude loses context and makes more mistakes. Consider starting fresh sessions for unrelated work streams.\n\n:::prompt\nLet's focus on one thing: I need to [specific task]. Don't plan ahead for other work — just complete this task, verify it works, and we'll move on.\n:::\n\n### Verify data assumptions before implementing features\n\nThe Wrapped feature built around a non-existent JSON file, the Google Ads overclaimed campaign status, and Azure quota issues all stem from Claude assuming rather than checking. For features that depend on external data or APIs, ask Claude to first verify the actual data format or system state before writing code. This one habit would have prevented at least 5 major reverts.\n\n:::prompt\nBefore implementing anything, first check: what does the actual data/API response look like? Read the relevant files, run a test command, or show me what we're working with. Don't assume the format — verify it.\n:::\n\n### Front-load context to avoid wrong_approach (51 incidents)\n\nMy #1 friction type is 'wrong_approach' at 51 occurrences — more than buggy_code. This often happens when Claude doesn't understand my project structure and makes incorrect assumptions about where code lives or how components interact. A 2-3 line context dump at the start of each session dramatically reduces this. My CLAUDE.md should contain my project's key architectural decisions so Claude never has to guess.\n\n:::prompt\nBefore starting, read CLAUDE.md and the project structure. This is a Next.js app with App Router. The dashboard is at /app/dashboard, API routes are in /app/api, and Supabase is our database. Now implement [task].\n:::\n\n### Demand working code, not plans\n\nAt least 4 sessions failed (not_achieved) because Claude spent the entire time reading files and writing plans without producing code. I've already been interrupting these — but I can prevent it entirely by being explicit upfront. The pattern is especially bad on creative/greenfield tasks (Remotion videos, blog sites) where Claude defaults to over-analysis. My 'excessive_planning' friction confirms this is a recurring issue.\n\n:::prompt\nImplement this now — no planning phase. Start writing code in the first file within 60 seconds. If you need to understand the codebase, read files as you go, don't batch all reading upfront.\n:::\n\n### Add 'no planning mode' guardrails for implementation tasks\n\nAt least 5 sessions were rated 'not_achieved' or 'slightly_helpful' because Claude spent 8+ minutes reading files and writing plans without producing code. This is my most consistent frustration pattern. When I already know what I want, be direct about skipping the exploration phase. My best sessions are the ones where Claude starts coding immediately — like the Calendly connector (12 files, 1,352 lines in one session).\n\n:::prompt\nSkip planning. I already know what I want. Start implementing immediately: [describe feature]. If you hit a blocker, ask me — don't spend time exploring the codebase.\n:::\n\n### Front-load deployment verification\n\nMultiple sessions had post-push friction: Vercel env vars with trailing newlines causing 500 errors, migrations failing silently, build failures from server/client component mismatches. I deploy frequently (21 deployment sessions), so adding a pre-deployment checklist prompt would save significant debugging time. The Stripe Connect session and MCP endpoint 500 error are prime examples of issues caught too late.\n\n:::prompt\nBefore we push this PR, run through a deployment checklist: 1) Verify the build passes locally, 2) Check if any new env vars are needed, 3) Verify any Supabase migrations will apply cleanly, 4) Confirm no server/client component boundary violations.\n:::\n\n\n## Features You're Probably Not Using\n\n### Custom Skills\n\n*Reusable prompts for repetitive workflows triggered by a single /command.*\n\nI have highly repetitive workflows: processing meeting transcripts into vault notes, creating PRs with code review, and deploying. I already built a weekly report skill — extend this pattern to my other common flows like /meeting, /pr, and /deploy to avoid re-explaining conventions each session.\n\n```\nmkdir -p .claude/skills/meeting && cat > .claude/skills/meeting/SKILL.md << 'EOF'\n# Process Meeting Transcript\n1. Read the provided transcript\n2. Check existing project files in vault for related projects\n3. Create meeting note in Meetings/ with attendees, summary, and references\n4. Route action items to their respective PROJECT files (never leave in meeting note)\n5. Route decisions to their respective PROJECT files\n6. Update People/ notes with any new context about attendees\n7. Update the project hub if any new projects are mentioned\nEOF\n```\n\n### Hooks\n\n*Auto-run shell commands at lifecycle events like pre-commit or post-edit.*\n\nWith 56 buggy code friction events and TypeScript as my primary language, auto-running `tsc --noEmit` or `npm run build` after edits would catch type errors and build failures before I have to point them out. This eliminates the back-and-forth debugging cycles that eat my time.\n\n```\n// Add to .claude/settings.json\n{\n  \"hooks\": {\n    \"postToolUse\": [\n      {\n        \"matcher\": \"Edit|Write\",\n        \"command\": \"npx tsc --noEmit --pretty 2>&1 | head -20\",\n        \"timeout\": 15000\n      }\n    ]\n  }\n}\n```\n\n### Headless Mode\n\n*Run Claude non-interactively for automated tasks from scripts or CI.*\n\nI have 25 deployment sessions and 11 create-PR sessions — these follow predictable patterns. Headless mode lets I script my deploy and PR workflows so I can kick them off with a single command instead of interactive back-and-forth.\n\n```\n# Quick PR creation script - save as scripts/create-pr.sh\n#!/bin/bash\nclaude -p \"Run the test suite, fix any failures, then create a PR to main with a descriptive title and body summarizing all changes since the last PR\" --allowedTools \"Bash,Read,Edit,Write,Grep\"\n```\n\n### Task Agents\n\n*Claude spawns focused sub-agents for parallel exploration or complex work.*\n\nMy architecture audit session already used 8 parallel sub-agents successfully. With 42 bug-fix sessions and complex multi-file changes (98 success events), I could use task agents more deliberately — e.g., 'use an agent to investigate the root cause while I describe the symptoms' or for parallel exploration of large codebases before implementation.\n\n```\nTry prompting: \"Use a task agent to explore all the MCP tool handlers and list any that don't properly await async database operations, while you start fixing the ones I already know about in the simulator service.\"\n```\n\n\n## CLAUDE.md: The Most Underrated Feature\n\nYour `CLAUDE.md` file is loaded at the start of every session. It's the single highest-leverage thing you can configure. Here are the rules I'd add based on 338 sessions of friction data:\n\n:::callout{type=\"tip\"}\n**Add this rule:** When asked to implement a feature, START CODING IMMEDIATELY. Do not spend more than 2 minutes reading files and planning before producing actual code. If you need to explore, do it incrementally while building.\n\n**Why it matters:** Multiple sessions (5+) were derailed by Claude spending entire sessions in planning/exploration loops without producing any code, leading to user interruption and 'not_achieved' outcomes.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** This is a Next.js + TypeScript + Supabase project deployed on Vercel. Always ensure files with JSX use .tsx extension. Always run `npx tsc --noEmit` before committing to catch type errors. Do not use `cookies().delete()` in Server Components — use Server Actions or Route Handlers for cookie mutations.\n\n**Why it matters:** Recurring friction across sessions: .ts vs .tsx rename issues, type errors surfacing after implementation, and a production error from cookie deletion in a Server Component — all preventable with upfront guardrails.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When deploying to Vercel or setting env vars via CLI, always confirm the correct Vercel project is linked first with `vercel link`. Trim all environment variable values with `.trim()` to prevent trailing newline issues.\n\n**Why it matters:** Multiple sessions hit friction from Vercel CLI linking to the wrong project and from trailing newlines in env vars causing 500 errors in production.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When working with Supabase migrations, always verify migrations actually executed (not ghost-applied) by checking the actual database state after running them. If Supabase CLI isn't authenticated for cloud push, tell the user immediately rather than proceeding with local-only changes.\n\n**Why it matters:** A critical bug fix appeared complete but the migration was ghost-applied (recorded but never executed), requiring a repair migration. Supabase auth issues blocked deploys in multiple sessions.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** For git push operations: try SSH first, then HTTPS with `gh auth setup-git` as fallback. Always push to the correct branch (main vs feature branch). Never push to a feature branch that has already been merged.\n\n**Why it matters:** Multiple sessions had git push friction — SSH/HTTPS failures, and one session accidentally pushed to an already-merged feature branch instead of main.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When using sub-agents/Task tool for parallel work, limit to 4-5 concurrent agents max. Summarize sub-agent results concisely rather than feeding full outputs back into the main context.\n\n**Why it matters:** A session dispatching 11+ parallel sub-agents overwhelmed the context window, causing every response to be truncated with 'Prompt is too long' errors.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Never screenshot localhost URLs — always use the production/deployed URL. Never include hardcoded API keys or secrets in committed code. Always check for sensitive data before committing.\n\n**Why it matters:** Sessions hit friction from attempting to screenshot localhost (redirected to login) and from a hardcoded API key nearly being committed in a 62-file commit.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When asked to implement something, START CODING IMMEDIATELY. Do not spend more than 2 minutes reading files and planning before producing actual code. If you need to explore, do it incrementally alongside implementation, not as a separate phase.\n\n**Why it matters:** Multiple sessions (Remotion video, dev blog, demo page) failed because Claude spent 8+ minutes in planning/exploration loops without producing any output before the user interrupted.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Always run `npm run build` (or equivalent) and verify no TypeScript/build errors before reporting a task as complete. Never say 'all set up' or 'done' without verifying the build passes.\n\n**Why it matters:** Repeated friction from buggy code shipping (55 instances) — build failures from server/client component mismatches, type errors, missing env vars, and unawaited async calls that required user-reported bug fixes.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When creating meeting notes or organizing information across multiple project files, ask upfront which projects each item belongs to rather than guessing and requiring manual corrections.\n\n**Why it matters:** Claude repeatedly misplaced action items and decisions into wrong project files, requiring multiple correction rounds from the user.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** After completing git operations (push, cherry-pick, merge), always confirm the push actually went through by running `git log --oneline -3` on the target branch. Don't assume a cherry-pick was pushed just because it was applied locally.\n\n**Why it matters:** User had to ask twice about pushing to main because Claude didn't push the cherry-pick, and there were multiple git workflow gaps across 32 git_operations sessions.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** This is a TypeScript/Next.js project. Key rules:\n- Never import client-only functions in Server Components\n- Always use `await` on async database operations (especially in serverless/Vercel)\n- Use `.tsx` extension for files containing JSX\n- Check that `useSearchParams()` is wrapped in Suspense for Next.js prerendering\n\n**Why it matters:** These exact TypeScript/Next.js bugs recurred across multiple sessions — server component imports, unawaited Supabase inserts causing data loss on Vercel, .ts/.tsx extension issues, and useSearchParams prerender failures.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Never overclaim completion status. If only 1 of 3 items is done, say '1 of 3 completed' — not 'all set up'. Be precise about what is actually working vs. what still needs attention.\n\n**Why it matters:** Claude overclaimed campaign status in Google Ads session and gave conflicting answers on Stripe Connect setup, eroding user trust and requiring corrections.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When I ask a simple question or request a quick edit, do NOT escalate into full architecture planning, file creation, or plan mode. Ask first if I want a deeper exploration.\n\n**Why it matters:** Multiple sessions show Claude over-expanding simple questions into full architecture plans or multi-file workflows, leading to user interruptions and frustration.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** For Obsidian vault updates: action items and decisions belong in their respective PROJECT files, not in meeting notes. Meeting notes should reference projects but not duplicate structured data.\n\n**Why it matters:** Across multiple vault sessions, Claude repeatedly placed action items and decisions in meeting notes instead of project files, requiring manual correction each time.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When creating meeting notes or processing transcripts, always cross-reference existing project files and people notes before writing. Route information to the correct existing file rather than creating duplicates or misplacing content.\n\n**Why it matters:** Multiple sessions required the user to correct Claude for misplacing content, creating duplicate person notes, or failing to check existing vault structure before writing.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Prefer action over planning. When I give you a task, start implementing immediately unless it's genuinely ambiguous. Don't enter plan mode or lengthy exploration for straightforward requests.\n\n**Why it matters:** Several sessions show the user interrupting Claude's planning/exploration loops — the user clearly prefers fast execution over structured multi-step planning for known tasks.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** This project primarily uses TypeScript. Always write TypeScript (not JavaScript) for new files. Follow existing type patterns in the codebase.\n\n**Why it matters:** TypeScript dominates the codebase at 4139 file touches vs 110 JavaScript — codifying this prevents Claude from defaulting to JS in new files.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** After implementing changes, always build/compile to verify before committing. Don't claim something is working without confirming it builds and type-checks cleanly.\n\n**Why it matters:** Buggy code was the #1 friction point (56 occurrences) alongside wrong approach (54), often because Claude didn't verify builds before declaring completion.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When I say 'push' or 'create PR', actually push the commits to the remote. Don't stop at local commits — complete the full git operation I requested.\n\n**Why it matters:** Git operations are the second most common goal (32 sessions), and friction occurred when Claude didn't follow through on pushes (e.g., cherry-pick not pushed, user asking twice).\n:::\n\n## The One-Minute Setup That Prevents Most Problems\n\nIf you only do one thing from this post, do this: add a pre-commit hook that runs your type checker. Most of the bugs Claude ships are type errors that would be caught instantly.\n\n```json\n// .claude/settings.json\n{\n  \"hooks\": {\n    \"preCommit\": {\n      \"command\": \"npx tsc --noEmit && npm run build\"\n    }\n  }\n}\n```\n\nThis single change would have prevented the majority of my 53 buggy code incidents.",
  "highlights": [
    "Custom Skills",
    "Hooks",
    "Headless Mode",
    "Task Agents",
    "CLAUDE.md rules",
    "Copyable prompts"
  ],
  "keyTakeaway": "Add a CLAUDE.md rule: 'start coding immediately, don't over-plan' and a pre-commit hook that runs tsc. These two changes prevent most friction."
}