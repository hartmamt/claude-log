{
  "slug": "power-user-tips",
  "title": "Claude Code Power User Guide",
  "subtitle": "Battle-tested prompts, CLAUDE.md rules, and workflow tricks from 178 sessions",
  "date": "2026-02-25",
  "category": "Tips",
  "categoryColor": "green",
  "icon": "zap",
  "readingTime": "10 min read",
  "content": "This is the post I wish I'd read before my first session. No theory, no hype — just the specific things that make Claude Code dramatically more effective.\n\n## The Prompts That Work\n\n### Break long sessions into focused tasks\n\nSessions that combined feature implementation + bug fixes + PR creation + code review + new feature planning had the most 'mostly_achieved' outcomes. My fully_achieved rate is highest when sessions have a single clear goal (e.g., 'implement Calendly connector' or 'fix bug and push PR'). With 496 Task agent invocations already, I'm leveraging sub-agents, but the parent sessions still try to do too much. Keep each session to one deliverable.\n\n:::prompt\nLet's focus on one thing: implement [feature X]. After it builds cleanly and tests pass, create a PR. Don't plan anything else.\n:::\n\n### Front-load context to avoid wrong_approach (51 incidents)\n\nMy #1 friction type is 'wrong_approach' at 51 occurrences — more than buggy_code. This often happens when Claude doesn't understand my project structure and makes incorrect assumptions about where code lives or how components interact. A 2-3 line context dump at the start of each session dramatically reduces this. My CLAUDE.md should contain my project's key architectural decisions so Claude never has to guess.\n\n:::prompt\nBefore starting, read CLAUDE.md and the project structure. This is a Next.js app with App Router. The dashboard is at /app/dashboard, API routes are in /app/api, and Supabase is our database. Now implement [task].\n:::\n\n### Demand working code, not plans\n\nAt least 4 sessions failed (not_achieved) because Claude spent the entire time reading files and writing plans without producing code. I've already been interrupting these — but I can prevent it entirely by being explicit upfront. The pattern is especially bad on creative/greenfield tasks (Remotion videos, blog sites) where Claude defaults to over-analysis. My 'excessive_planning' friction confirms this is a recurring issue.\n\n:::prompt\nImplement this now — no planning phase. Start writing code in the first file within 60 seconds. If you need to understand the codebase, read files as you go, don't batch all reading upfront.\n:::\n\n### Add 'no planning mode' guardrails for implementation tasks\n\nAt least 5 sessions were rated 'not_achieved' or 'slightly_helpful' because Claude spent 8+ minutes reading files and writing plans without producing code. This is my most consistent frustration pattern. When I already know what I want, be direct about skipping the exploration phase. My best sessions are the ones where Claude starts coding immediately — like the Calendly connector (12 files, 1,352 lines in one session).\n\n:::prompt\nSkip planning. I already know what I want. Start implementing immediately: [describe feature]. If you hit a blocker, ask me — don't spend time exploring the codebase.\n:::\n\n### Front-load deployment verification\n\nMultiple sessions had post-push friction: Vercel env vars with trailing newlines causing 500 errors, migrations failing silently, build failures from server/client component mismatches. I deploy frequently (21 deployment sessions), so adding a pre-deployment checklist prompt would save significant debugging time. The Stripe Connect session and MCP endpoint 500 error are prime examples of issues caught too late.\n\n:::prompt\nBefore we push this PR, run through a deployment checklist: 1) Verify the build passes locally, 2) Check if any new env vars are needed, 3) Verify any Supabase migrations will apply cleanly, 4) Confirm no server/client component boundary violations.\n:::\n\n\n## Features You're Probably Not Using\n\n### Custom Skills\n\n*Reusable prompts that run with a single /command for repetitive workflows.*\n\nI have highly repetitive workflows: creating PRs (11 sessions), running code reviews before pushing, doing bug fix → review → PR cycles, and creating Obsidian meeting notes from transcripts. Each of these follows a predictable pattern I shouldn't have to re-explain every time.\n\n```\nmkdir -p .claude/skills/pr && cat > .claude/skills/pr/SKILL.md << 'EOF'\n## Create PR Workflow\n1. Run `npm run build` and fix any errors\n2. Run `npx tsc --noEmit` to verify types\n3. Stage all changes with `git add -A`\n4. Create a descriptive commit message based on the changes\n5. Push the branch to origin\n6. Create a PR with `gh pr create --fill`\n7. Report the PR URL\nEOF\n```\n\n### Hooks\n\n*Shell commands that auto-run at specific lifecycle events like pre-commit or post-edit.*\n\nWith 55 buggy_code friction events and 51 wrong_approach incidents, auto-running `npm run build` or `npx tsc --noEmit` after edits would catch the server/client component mismatches, type errors, and unawaited async issues before Claude declares 'done'.\n\n```\nAdd to .claude/settings.json:\n{\n  \"hooks\": {\n    \"postToolUse\": [\n      {\n        \"matcher\": \"Edit|Write\",\n        \"command\": \"npx tsc --noEmit --pretty 2>&1 | head -20\"\n      }\n    ]\n  }\n}\n```\n\n### Headless Mode\n\n*Run Claude non-interactively from scripts and CI/CD pipelines.*\n\nWith 25 deployment sessions and 264 commits, I could automate pre-deploy checks, lint fixes, and code review as part of my CI pipeline instead of running them manually in interactive sessions. This would also help with the 12 'prompt_too_long' friction events by keeping focused automated tasks short.\n\n```\n# Add to your CI pipeline or a pre-push git hook:\nclaude -p \"Review the changes in this PR for bugs, type safety issues, and server/client component boundary violations. Focus on: unawaited async calls, missing Suspense boundaries, and incorrect file extensions.\" --allowedTools \"Read,Grep,Glob,Bash\"\n```\n\n### Task Agents\n\n*Claude spawns focused sub-agents for parallel exploration or complex work.*\n\nMy architecture audit session already used 8 parallel sub-agents successfully. With 42 bug-fix sessions and complex multi-file changes (98 success events), I could use task agents more deliberately — e.g., 'use an agent to investigate the root cause while I describe the symptoms' or for parallel exploration of large codebases before implementation.\n\n```\nTry prompting: \"Use a task agent to explore all the MCP tool handlers and list any that don't properly await async database operations, while you start fixing the ones I already know about in the simulator service.\"\n```\n\n\n## CLAUDE.md: The Most Underrated Feature\n\nYour `CLAUDE.md` file is loaded at the start of every session. It's the single highest-leverage thing you can configure. Here are the rules I'd add based on 178 sessions of friction data:\n\n:::callout{type=\"tip\"}\n**Add this rule:** When asked to implement a feature, START CODING IMMEDIATELY. Do not spend more than 2 minutes reading files and planning before producing actual code. If you need to explore, do it incrementally while building.\n\n**Why it matters:** Multiple sessions (5+) were derailed by Claude spending entire sessions in planning/exploration loops without producing any code, leading to user interruption and 'not_achieved' outcomes.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** This is a Next.js + TypeScript + Supabase project deployed on Vercel. Always ensure files with JSX use .tsx extension. Always run `npx tsc --noEmit` before committing to catch type errors. Do not use `cookies().delete()` in Server Components — use Server Actions or Route Handlers for cookie mutations.\n\n**Why it matters:** Recurring friction across sessions: .ts vs .tsx rename issues, type errors surfacing after implementation, and a production error from cookie deletion in a Server Component — all preventable with upfront guardrails.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When deploying to Vercel or setting env vars via CLI, always confirm the correct Vercel project is linked first with `vercel link`. Trim all environment variable values with `.trim()` to prevent trailing newline issues.\n\n**Why it matters:** Multiple sessions hit friction from Vercel CLI linking to the wrong project and from trailing newlines in env vars causing 500 errors in production.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When working with Supabase migrations, always verify migrations actually executed (not ghost-applied) by checking the actual database state after running them. If Supabase CLI isn't authenticated for cloud push, tell the user immediately rather than proceeding with local-only changes.\n\n**Why it matters:** A critical bug fix appeared complete but the migration was ghost-applied (recorded but never executed), requiring a repair migration. Supabase auth issues blocked deploys in multiple sessions.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** For git push operations: try SSH first, then HTTPS with `gh auth setup-git` as fallback. Always push to the correct branch (main vs feature branch). Never push to a feature branch that has already been merged.\n\n**Why it matters:** Multiple sessions had git push friction — SSH/HTTPS failures, and one session accidentally pushed to an already-merged feature branch instead of main.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When using sub-agents/Task tool for parallel work, limit to 4-5 concurrent agents max. Summarize sub-agent results concisely rather than feeding full outputs back into the main context.\n\n**Why it matters:** A session dispatching 11+ parallel sub-agents overwhelmed the context window, causing every response to be truncated with 'Prompt is too long' errors.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Never screenshot localhost URLs — always use the production/deployed URL. Never include hardcoded API keys or secrets in committed code. Always check for sensitive data before committing.\n\n**Why it matters:** Sessions hit friction from attempting to screenshot localhost (redirected to login) and from a hardcoded API key nearly being committed in a 62-file commit.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When asked to implement something, START CODING IMMEDIATELY. Do not spend more than 2 minutes reading files and planning before producing actual code. If you need to explore, do it incrementally alongside implementation, not as a separate phase.\n\n**Why it matters:** Multiple sessions (Remotion video, dev blog, demo page) failed because Claude spent 8+ minutes in planning/exploration loops without producing any output before the user interrupted.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Always run `npm run build` (or equivalent) and verify no TypeScript/build errors before reporting a task as complete. Never say 'all set up' or 'done' without verifying the build passes.\n\n**Why it matters:** Repeated friction from buggy code shipping (55 instances) — build failures from server/client component mismatches, type errors, missing env vars, and unawaited async calls that required user-reported bug fixes.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** When creating meeting notes or organizing information across multiple project files, ask upfront which projects each item belongs to rather than guessing and requiring manual corrections.\n\n**Why it matters:** Claude repeatedly misplaced action items and decisions into wrong project files, requiring multiple correction rounds from the user.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** After completing git operations (push, cherry-pick, merge), always confirm the push actually went through by running `git log --oneline -3` on the target branch. Don't assume a cherry-pick was pushed just because it was applied locally.\n\n**Why it matters:** User had to ask twice about pushing to main because Claude didn't push the cherry-pick, and there were multiple git workflow gaps across 32 git_operations sessions.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** This is a TypeScript/Next.js project. Key rules:\n- Never import client-only functions in Server Components\n- Always use `await` on async database operations (especially in serverless/Vercel)\n- Use `.tsx` extension for files containing JSX\n- Check that `useSearchParams()` is wrapped in Suspense for Next.js prerendering\n\n**Why it matters:** These exact TypeScript/Next.js bugs recurred across multiple sessions — server component imports, unawaited Supabase inserts causing data loss on Vercel, .ts/.tsx extension issues, and useSearchParams prerender failures.\n:::\n\n:::callout{type=\"tip\"}\n**Add this rule:** Never overclaim completion status. If only 1 of 3 items is done, say '1 of 3 completed' — not 'all set up'. Be precise about what is actually working vs. what still needs attention.\n\n**Why it matters:** Claude overclaimed campaign status in Google Ads session and gave conflicting answers on Stripe Connect setup, eroding user trust and requiring corrections.\n:::\n\n## The One-Minute Setup That Prevents Most Problems\n\nIf you only do one thing from this post, do this: add a pre-commit hook that runs your type checker. Most of the bugs Claude ships are type errors that would be caught instantly.\n\n```json\n// .claude/settings.json\n{\n  \"hooks\": {\n    \"preCommit\": {\n      \"command\": \"npx tsc --noEmit && npm run build\"\n    }\n  }\n}\n```\n\nThis single change would have prevented the majority of my 53 buggy code incidents.",
  "highlights": [
    "Custom Skills",
    "Hooks",
    "Headless Mode",
    "Task Agents",
    "CLAUDE.md rules",
    "Copyable prompts"
  ],
  "keyTakeaway": "Add a CLAUDE.md rule: 'start coding immediately, don't over-plan' and a pre-commit hook that runs tsc. These two changes prevent most friction."
}